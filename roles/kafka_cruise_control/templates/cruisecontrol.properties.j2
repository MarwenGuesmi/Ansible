#
# Copyright 2017 LinkedIn Corp. Licensed under the BSD 2-Clause License (the "License"). See License in the project root for license information.
#

# This is an example property file for Kafka Cruise Control. See com.linkedin.kafka.cruisecontrol.config.constants for more details.

# Configuration for the metadata client.
# =======================================

# The Kafka cluster to control.
bootstrap.servers={{ cruise_bootstrap_connect }}

# The maximum interval in milliseconds between two metadata refreshes.
#metadata.max.age.ms=300000

# Client id for the Cruise Control. It is used for the metadata client.
#client.id=kafka-cruise-control

# The size of TCP send buffer bytes for the metadata client.
#send.buffer.bytes=131072

# The size of TCP receive buffer size for the metadata client.
#receive.buffer.bytes=131072

# The time to wait before disconnect an idle TCP connection.
#connections.max.idle.ms=540000

# The time to wait before reconnect to a given host.
#reconnect.backoff.ms=50

# The time to wait for a response from a host after sending a request.
#request.timeout.ms=30000

# The time to wait for broker logdir to respond after sending a request.
#logdir.response.timeout.ms=10000

# Configurations for the load monitor
# =======================================

# The number of metric fetcher thread to fetch metrics for the Kafka cluster
num.metric.fetchers={{ metrics_fetchers_num }}

# The metric sampler class
metric.sampler.class={{ metric_class }}

# True if the sampling process allows CPU capacity estimation of brokers used for CPU utilization estimation.
sampling.allow.cpu.capacity.estimation={{ cpu_capacity_estimation }}

# Configurations for CruiseControlMetricsReporterSampler
metric.reporter.topic={{ metric_reporter_topic }}

# The sample store class name
sample.store.class={{ store_class }}

# The config for the Kafka sample store to save the partition metric samples
partition.metric.sample.store.topic={{ partition_store_topic }}

# The config for the Kafka sample store to save the model training samples
broker.metric.sample.store.topic={{ broker_store_topic }}

# The replication factor of Kafka metric sample store topic
sample.store.topic.replication.factor={{ topic_replication_factor }}

# The config for the number of Kafka sample store consumer threads
num.sample.loading.threads={{ threads_loading_num }}

# The partition assignor class for the metric samplers
metric.sampler.partition.assignor.class={{ metric_partition_assignor_class }}

# The metric sampling interval in milliseconds
metric.sampling.interval.ms={{ metrics_interval_ms }}

# The partition metrics window size in milliseconds
partition.metrics.window.ms={{ partition_metrics }}

# The number of partition metric windows to keep in memory. Partition-load-history = num.partition.metrics.windows * partition.metrics.window.ms
num.partition.metrics.windows={{ partition_metrics_windows }}

# The minimum partition metric samples required for a partition in each window
min.samples.per.partition.metrics.window={{ min_samples_per_partition }}

# The broker metrics window size in milliseconds
broker.metrics.window.ms={{ broker_metrics_ms }}

# The number of broker metric windows to keep in memory. Broker-load-history = num.broker.metrics.windows * broker.metrics.window.ms
num.broker.metrics.windows={{ num_broker_metrics }}

# The minimum broker metric samples required for a partition in each window
min.samples.per.broker.metrics.window={{ min_samples_per_broker }}

# The configuration for the BrokerCapacityConfigFileResolver (supports JBOD, non-JBOD, and heterogeneous CPU core capacities)
#capacity.config.file=config/capacity.json
capacity.config.file={{ capacity_config_file }}

# Configurations for the analyzer
# =======================================

# The list of goals to optimize the Kafka cluster for with pre-computed proposals -- consider using RackAwareDistributionGoal instead of RackAwareGoal in clusters with partitions whose replication factor > number of racks
default.goals={{ default_goals }}

# The list of supported goals
goals={{ supported_goals }}

# The list of supported intra-broker goals
intra.broker.goals={{ intra_broker_goals }}

# The list of supported hard goals -- consider using RackAwareDistributionGoal instead of RackAwareGoal in clusters with partitions whose replication factor > number of racks
hard.goals={{ hard_goals }} 

# The minimum percentage of well monitored partitions out of all the partitions
min.valid.partition.ratio={{ min_valid_partition }}

# The balance threshold for CPU
cpu.balance.threshold={{ cpu_balance }}

# The balance threshold for disk
disk.balance.threshold={{ disk_balance }}

# The balance threshold for network inbound utilization
network.inbound.balance.threshold={{ network_inbound_balance }}

# The balance threshold for network outbound utilization
network.outbound.balance.threshold={{ network_outbound_balance }}

# The balance threshold for the replica count
replica.count.balance.threshold={{ replica_count_balance }}

# The capacity threshold for CPU in percentage
cpu.capacity.threshold={{ cpu_capacity_percent }}

# The capacity threshold for disk in percentage
disk.capacity.threshold={{ disk_capacity_percent }}

# The capacity threshold for network inbound utilization in percentage
network.inbound.capacity.threshold={{ network_inbound_capacity_percent }}

# The capacity threshold for network outbound utilization in percentage
network.outbound.capacity.threshold={{ network_outbound_capacity_percent }}

# The threshold to define the cluster to be in a low CPU utilization state
cpu.low.utilization.threshold={{ cpu_low_utulization }}

# The threshold to define the cluster to be in a low disk utilization state
disk.low.utilization.threshold={{ disk_low_utulization }}

# The threshold to define the cluster to be in a low network inbound utilization state
network.inbound.low.utilization.threshold={{ network_inbound_low_utulization }}

# The threshold to define the cluster to be in a low network outbound utilization state
network.outbound.low.utilization.threshold={{ network_outbound_low_utulization }}

# The metric anomaly percentile upper threshold
metric.anomaly.percentile.upper.threshold={{ metric_anomaly_upper }}

# The metric anomaly percentile lower threshold
metric.anomaly.percentile.lower.threshold={{ metric_anomaly_lower }}

# How often should the cached proposal be expired and recalculated if necessary
proposal.expiration.ms={{ proposal_expiration_ms }}

# The maximum number of replicas that can reside on a broker at any given time.
max.replicas.per.broker={{ max_replicas_per_broker }}

# The number of threads to use for proposal candidate precomputing.
num.proposal.precompute.threads={{ num_proposal_precompute_threads }}

# the topics that should be excluded from the partition movement.
#topics.excluded.from.partition.movement

# The impact of having one level higher goal priority on the relative balancedness score.
#goal.balancedness.priority.weight

# The impact of strictness on the relative balancedness score.
#goal.balancedness.strictness.weight

# Configurations for the executor
# =======================================

# The zookeeper connect of the Kafka cluster
zookeeper.connect={{ zookeeper_connect }}

# If true, appropriate zookeeper Client { .. } entry required in jaas file located at $base_dir/config/cruise_control_jaas.conf
zookeeper.security.enabled={{ zookeeper_security }}

# The max number of partitions to move in/out on a given broker at a given time.
num.concurrent.partition.movements.per.broker={{ partition_movements_per_broker }}

# The max number of partitions to move between disks within a given broker at a given time.
num.concurrent.intra.broker.partition.movements={{ intra_broker_partition_movements }}

# The max number of leadership movement within the whole cluster at a given time.
num.concurrent.leader.movements={{ num_leader_movements }}

# Default replica movement throttle. If not specified, movements unthrottled by default.
# default.replication.throttle=

# The interval between two execution progress checks.
execution.progress.check.interval.ms={{ progress_check_interval_ms }}


# Configurations for anomaly detector
# =======================================

# The goal violation notifier class
anomaly.notifier.class={{ anomaly_notifier_class }}

# The metric anomaly finder class
metric.anomaly.finder.class={{ metric_anomaly_finderclass }}

# The anomaly detection interval
#anomaly.detection.interval.ms=10000

# The goal violation to detect -- consider using RackAwareDistributionGoal instead of RackAwareGoal in clusters with partitions whose replication factor > number of racks
anomaly.detection.goals={{ anomaly_detection_goals }}

# The interested metrics for metric anomaly analyzer.
metric.anomaly.analyzer.metrics={{ metric_anomaly_analyzer }}

# True if recently demoted brokers are excluded from optimizations during self healing, false otherwise
self.healing.exclude.recently.demoted.brokers={{ self_healing_demoted_brokers }}

# True if recently removed brokers are excluded from optimizations during self healing, false otherwise
self.healing.exclude.recently.removed.brokers={{ self_healing_removed_brokers }}

# The zk path to store failed broker information.
failed.brokers.zk.path={{ failed_brokers_path }}

# Topic config provider class
topic.config.provider.class={{ topic_config_providerclass }}

# The cluster configurations for the KafkaTopicConfigProvider
cluster.configs.file={{ cluster_configs_file }}

# The maximum time in milliseconds to store the response and access details of a completed kafka monitoring user task.
completed.kafka.monitor.user.task.retention.time.ms={{ kafka_monitor_usertask_done_ms }}

# The maximum time in milliseconds to store the response and access details of a completed cruise control monitoring user task.
completed.cruise.control.monitor.user.task.retention.time.ms={{ cruise_monitor_usertask_done_ms }}

# The maximum time in milliseconds to store the response and access details of a completed kafka admin user task.
completed.kafka.admin.user.task.retention.time.ms={{ kafka_monitor_admintask_done_ms }}

# The maximum time in milliseconds to store the response and access details of a completed cruise control admin user task.
completed.cruise.control.admin.user.task.retention.time.ms={{ cruise_monitor_admintask_done_ms }}

# The fallback maximum time in milliseconds to store the response and access details of a completed user task.
completed.user.task.retention.time.ms={{ usertask_done_ms }}

# The maximum time in milliseconds to retain the demotion history of brokers.
demotion.history.retention.time.ms={{ demotion_history_ms }}

# The maximum time in milliseconds to retain the removal history of brokers.
removal.history.retention.time.ms={{ removal_history_ms }} 

# The maximum number of completed kafka monitoring user tasks for which the response and access details will be cached.
max.cached.completed.kafka.monitor.user.tasks={{ max_cached_kafkamonitor_usertasks_done }}

# The maximum number of completed cruise control monitoring user tasks for which the response and access details will be cached.
max.cached.completed.cruise.control.monitor.user.tasks={{ max_cached_cruise_usertasks_done }}

# The maximum number of completed kafka admin user tasks for which the response and access details will be cached.
max.cached.completed.kafka.admin.user.tasks={{ max_cached_kafka_adminuser_tasks_done }}

# The maximum number of completed cruise control admin user tasks for which the response and access details will be cached.
max.cached.completed.cruise.control.admin.user.tasks={{ max_cached_cruise_admintasks_done }}

# The fallback maximum number of completed user tasks of certain type for which the response and access details will be cached.
max.cached.completed.user.tasks={{ max_cached_usertasks_done }}

# The maximum number of user tasks for concurrently running in async endpoints across all users.
max.active.user.tasks={{ max_active_user_tasks }}

# Enable self healing for all anomaly detectors, unless the particular anomaly detector is explicitly disabled
self.healing.enabled={{ self_healing }}

# Enable self healing for broker failure detector
#self.healing.broker.failure.enabled=true

# Enable self healing for goal violation detector
#self.healing.goal.violation.enabled=true

# Enable self healing for metric anomaly detector
#self.healing.metric.anomaly.enabled=true

# Enable self healing for disk failure detector
#self.healing.disk.failure.enabled=true

# Enable self healing for topic anomaly detector
#self.healing.topic.anomaly.enabled=true
#topic.anomaly.finder.class=com.linkedin.kafka.cruisecontrol.detector.TopicReplicationFactorAnomalyFinder

# Enable self healing for maintenance event detector
#self.healing.maintenance.event.enabled=true

# The multiplier applied to the threshold of distribution goals used by goal.violation.detector.
#goal.violation.distribution.threshold.multiplier=2.50

# configurations for the webserver
# ================================

# HTTP listen port
webserver.http.port={{ cruise_listen_port }}

# HTTP listen address
webserver.http.address={{ listen_adress }}

# Whether CORS support is enabled for API or not
webserver.http.cors.enabled={{ http_cors }}

# Value for Access-Control-Allow-Origin
webserver.http.cors.origin={{ http_cors_allow_access }}

# Value for Access-Control-Request-Method
webserver.http.cors.allowmethods={{ cors_allow_methods }}

# Headers that should be exposed to the Browser (Webapp)
# This is a special header that is used by the
# User Tasks subsystem and should be explicitly
# Enabled when CORS mode is used as part of the
# Admin Interface
webserver.http.cors.exposeheaders={{ cors_expose_headers }}

# REST API default prefix (dont forget the ending /*)
webserver.api.urlprefix={{ api_url_prefix }}

# Location where the Cruise Control frontend is deployed
webserver.ui.diskpath={{ ui_diskpath }}

# URL path prefix for UI (dont forget the ending /*)
webserver.ui.urlprefix={{ ui_urlprefix }}

# Time After which request is converted to Async
webserver.request.maxBlockTimeMs={{ request_maxblock }}

# Default Session Expiry Period
webserver.session.maxExpiryTimeMs={{ session_maxexpire }}

# Session cookie path
webserver.session.path={{ session_path }}

# Server Access Logs
webserver.accesslog.enabled={{ accesslog }}

# Location of HTTP Request Logs
webserver.accesslog.path={{ accesslog_path }}

# HTTP Request Log retention days
webserver.accesslog.retention.days={{ accesslog_days }}

# Configurations for servlet
# ==========================

# Enable two-step verification for processing POST requests.
two.step.verification.enabled={{ two_step_verification }}

# The maximum time in milliseconds to retain the requests in two-step (verification) purgatory.
two.step.purgatory.retention.time.ms={{ two_step_purgatory_retention }}

# The maximum number of requests in two-step (verification) purgatory.
two.step.purgatory.max.requests={{ two_step_purgatory_maxrequests }}
